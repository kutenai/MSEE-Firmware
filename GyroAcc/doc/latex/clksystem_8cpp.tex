\hypertarget{clksystem_8cpp}{
\section{clksystem.cpp File Reference}
\label{clksystem_8cpp}\index{clksystem.cpp@{clksystem.cpp}}
}
{\ttfamily \#include $<$avr/io.h$>$}\par
{\ttfamily \#include $<$util/delay.h$>$}\par
{\ttfamily \#include $<$avr/interrupt.h$>$}\par
{\ttfamily \#include $<$stdint.h$>$}\par
{\ttfamily \#include $<$stdbool.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{clksystem_8cpp_a0a4fb62f9e69209c9c8c8e34ebb3df6f}{AVR\_\-ENTER\_\-CRITICAL\_\-REGION}()
\begin{DoxyCompactList}\small\item\em This macro will protect the following code from interrupts. \item\end{DoxyCompactList}\item 
\#define \hyperlink{clksystem_8cpp_a770b47b04eec57748be0826a3d23503b}{AVR\_\-LEAVE\_\-CRITICAL\_\-REGION}()~SREG = saved\_\-sreg;
\begin{DoxyCompactList}\small\item\em This macro must always be used in conjunction with AVR\_\-ENTER\_\-CRITICAL\_\-REGION so the interrupts are enabled again. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{clksystem_8cpp_aad4e162434c2cc7e0087bbc0ddfe266c}{CCPWrite} (volatile uint8\_\-t $\ast$address, uint8\_\-t value)
\begin{DoxyCompactList}\small\item\em CCP write helper function written in assembly. \item\end{DoxyCompactList}\item 
void \hyperlink{clksystem_8cpp_a098d30ebaad7a94505407605314930e5}{clksystem\_\-init} ()
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{clksystem_8cpp_a0a4fb62f9e69209c9c8c8e34ebb3df6f}{
\index{clksystem.cpp@{clksystem.cpp}!AVR\_\-ENTER\_\-CRITICAL\_\-REGION@{AVR\_\-ENTER\_\-CRITICAL\_\-REGION}}
\index{AVR\_\-ENTER\_\-CRITICAL\_\-REGION@{AVR\_\-ENTER\_\-CRITICAL\_\-REGION}!clksystem.cpp@{clksystem.cpp}}
\subsubsection[{AVR\_\-ENTER\_\-CRITICAL\_\-REGION}]{\setlength{\rightskip}{0pt plus 5cm}\#define AVR\_\-ENTER\_\-CRITICAL\_\-REGION(
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{clksystem_8cpp_a0a4fb62f9e69209c9c8c8e34ebb3df6f}
{\bfseries Value:}
\begin{DoxyCode}
uint8_t volatile saved_sreg = SREG; \
                                     cli();
\end{DoxyCode}


This macro will protect the following code from interrupts. 



Definition at line 10 of file clksystem.cpp.



Referenced by CCPWrite().

\hypertarget{clksystem_8cpp_a770b47b04eec57748be0826a3d23503b}{
\index{clksystem.cpp@{clksystem.cpp}!AVR\_\-LEAVE\_\-CRITICAL\_\-REGION@{AVR\_\-LEAVE\_\-CRITICAL\_\-REGION}}
\index{AVR\_\-LEAVE\_\-CRITICAL\_\-REGION@{AVR\_\-LEAVE\_\-CRITICAL\_\-REGION}!clksystem.cpp@{clksystem.cpp}}
\subsubsection[{AVR\_\-LEAVE\_\-CRITICAL\_\-REGION}]{\setlength{\rightskip}{0pt plus 5cm}\#define AVR\_\-LEAVE\_\-CRITICAL\_\-REGION(
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)~SREG = saved\_\-sreg;}}
\label{clksystem_8cpp_a770b47b04eec57748be0826a3d23503b}


This macro must always be used in conjunction with AVR\_\-ENTER\_\-CRITICAL\_\-REGION so the interrupts are enabled again. 



Definition at line 16 of file clksystem.cpp.



Referenced by CCPWrite().



\subsection{Function Documentation}
\hypertarget{clksystem_8cpp_aad4e162434c2cc7e0087bbc0ddfe266c}{
\index{clksystem.cpp@{clksystem.cpp}!CCPWrite@{CCPWrite}}
\index{CCPWrite@{CCPWrite}!clksystem.cpp@{clksystem.cpp}}
\subsubsection[{CCPWrite}]{\setlength{\rightskip}{0pt plus 5cm}void CCPWrite (
\begin{DoxyParamCaption}
\item[{volatile uint8\_\-t $\ast$}]{address, }
\item[{uint8\_\-t}]{value}
\end{DoxyParamCaption}
)}}
\label{clksystem_8cpp_aad4e162434c2cc7e0087bbc0ddfe266c}


CCP write helper function written in assembly. 

This function is written in assembly because of the timecritial operation of writing to the registers.


\begin{DoxyParams}{Parameters}
{\em address} & A pointer to the address to write to. \\
\hline
{\em value} & The value to put in to the register. \\
\hline
\end{DoxyParams}


Definition at line 26 of file clksystem.cpp.



References AVR\_\-ENTER\_\-CRITICAL\_\-REGION, and AVR\_\-LEAVE\_\-CRITICAL\_\-REGION.


\begin{DoxyCode}
{
    AVR_ENTER_CRITICAL_REGION( );

    volatile uint8_t * tmpAddr = address;

    asm volatile(
        "movw r30,  %0"       "\n\t"
        "ldi  r16,  %2"       "\n\t"
        "out   %3, r16"       "\n\t"
        "st     Z,  %1"       "\n\t"
        :
        : "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
        : "r16", "r30", "r31"
    );

    AVR_LEAVE_CRITICAL_REGION( );
}
\end{DoxyCode}
\hypertarget{clksystem_8cpp_a098d30ebaad7a94505407605314930e5}{
\index{clksystem.cpp@{clksystem.cpp}!clksystem\_\-init@{clksystem\_\-init}}
\index{clksystem\_\-init@{clksystem\_\-init}!clksystem.cpp@{clksystem.cpp}}
\subsubsection[{clksystem\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void clksystem\_\-init (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{clksystem_8cpp_a098d30ebaad7a94505407605314930e5}


Definition at line 58 of file clksystem.cpp.



Referenced by init().


\begin{DoxyCode}
{
    // This board does not have an external oscillator,
    // so we need to use the internal oscillator.
    // Enable the internal 32Mhz oscillator. Disables all the rest.
    OSC.CTRL = OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm;

    //OSC.XOSCCTRL = 0; // we don't care, just set this to some value.

    // Wait for the external oscilator. Don't wait forever though.
    int maxWait = 100; // Wait 1 second
    while (--maxWait && !(OSC.STATUS & (OSC_RC32MRDY_bm | OSC_RC32KRDY_bm | OSC_R
      C2MRDY_bm))) {
        _delay_loop_2(10);
    }

    OSC.DFLLCTRL = 0;
    DFLLRC32M.CTRL = 0x1;
    DFLLRC2M.CTRL = 0x1;

    // If the external oscilator is running, then we can switch the PLL
    // over to it and wait for the PLL to stabilize.
    if (OSC.STATUS & ( OSC_RC32MRDY_bm | OSC_RC2MRDY_bm)) {
        // Setup the PLL to use the internal 32Mhz oscillator and a
        // factor of 4 to get a 128Mhz PLL Clock.

        // Make sure this is disabled before we try and configure it.
        OSC.CTRL &= ~OSC_PLLEN_bm;

        OSC.PLLCTRL = OSC_PLLSRC_RC32M_gc | (16 << OSC_PLLFAC_gp);

        OSC.CTRL |= OSC_PLLEN_bm;

        //OSC.CTRL = CLK_PSADIV_16_gc;
        // Wait for OSC.STATUS to indicate that PLL is ready..
        while (!(OSC.STATUS & OSC_PLLRDY_bm)) {
        }

        // Okay, the PLL is up on the new clock. Set the prescalers then
        // switch over to the PLL.

        CCP = CCP_IOREG_gc;
        CLK.PSCTRL = CLK_PSADIV_1_gc | CLK_PSBCDIV_2_2_gc;
        //CLK.PSCTRL = CLK_PSADIV_1_gc | CLK_PSBCDIV_1_1_gc;

        // When all is done, make the PLL be the clock source for the system.
        CCP = CCP_IOREG_gc;
        CLK.CTRL = CLK_SCLKSEL_PLL_gc;
        //CLK.CTRL = CLK_SCLKSEL_RC32M_gc;
        //CLK.CTRL = CLK_SCLKSEL_RC2M_gc;
    }
}
\end{DoxyCode}
